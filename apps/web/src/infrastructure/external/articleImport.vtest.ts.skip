import { vi } from 'vitest';
import { JSDOM } from "jsdom";
import axios from "axios";

// Mock dependencies
vi.mock("axios");
const mockedAxios = vi.mocked(axios);

// Set environment variables before importing the module
const originalFirecrawlKey = process.env.FIRECRAWL_KEY;
const originalDiffbotKey = process.env.DIFFBOT_KEY;
process.env.FIRECRAWL_KEY = 'test-firecrawl-key';
process.env.DIFFBOT_KEY = 'test-diffbot-key';

// Import after setting env var
import {
  extractContent,
  convertToMarkdown,
  processArticle,
  createCleanDOM,
} from './articleImport';

beforeEach(() => {
  vi.clearAllMocks();
});

afterAll(() => {
  // Restore original environment
  if (originalFirecrawlKey !== undefined) {
    process.env.FIRECRAWL_KEY = originalFirecrawlKey;
  } else {
    delete process.env.FIRECRAWL_KEY;
  }
  if (originalDiffbotKey !== undefined) {
    process.env.DIFFBOT_KEY = originalDiffbotKey;
  } else {
    delete process.env.DIFFBOT_KEY;
  }
});

describe("articleImport", () => {
  describe("createCleanDOM", () => {
    it("should strip out scripts and styles", () => {
      const html = `
        <html>
          <head>
            <script>alert('test');</script>
            <style>body { color: red; }</style>
            <link rel="stylesheet" href="test.css">
          </head>
          <body>
            <p>Test content</p>
            <script>console.log('another script');</script>
          </body>
        </html>
      `;
      
      const dom = createCleanDOM(html);
      const document = dom.window.document;
      
      expect(document.querySelectorAll("script").length).toBe(0);
      expect(document.querySelectorAll("style").length).toBe(0);
      expect(document.querySelectorAll("link").length).toBe(0);
      expect(document.querySelector("p")?.textContent).toBe("Test content");
    });
  });

  describe("extractContent", () => {
    it("should extract content from article tags", () => {
      const dom = new JSDOM(`
        <html>
          <body>
            <header>Header content</header>
            <article>
              <h1>Article Title</h1>
              <p>Article content</p>
            </article>
            <footer>Footer content</footer>
          </body>
        </html>
      `);
      
      const content = extractContent(dom);
      expect(content).toContain("Article Title");
      expect(content).toContain("Article content");
      expect(content).not.toContain("Header content");
      expect(content).not.toContain("Footer content");
    });

    it("should remove social sharing elements", () => {
      const dom = new JSDOM(`
        <html>
          <body>
            <article>
              <p>Real content</p>
              <div class="share-buttons">Share this!</div>
              <div class="social-widget">Follow us</div>
            </article>
          </body>
        </html>
      `);
      
      const content = extractContent(dom);
      expect(content).toContain("Real content");
      expect(content).not.toContain("Share this!");
      expect(content).not.toContain("Follow us");
    });
  });

  describe("convertToMarkdown", () => {
    it("should convert basic HTML to markdown", () => {
      const html = `
        <h1>Title</h1>
        <p>This is a <strong>bold</strong> and <em>italic</em> text.</p>
        <a href="https://example.com">Link</a>
      `;
      
      const markdown = convertToMarkdown(html);
      expect(markdown).toContain("# Title");
      expect(markdown).toContain("**bold**");
      expect(markdown).toContain("_italic_");
      expect(markdown).toContain("[Link](https://example.com)");
    });

    it("should handle linked images correctly", () => {
      const html = `
        <a href="https://substackcdn.com/image/fetch/image.jpg">
          <img src="https://substackcdn.com/image/fetch/image.jpg" alt="Test Image">
        </a>
      `;
      
      const markdown = convertToMarkdown(html);
      // The linked image rule should prevent nested link+image patterns
      expect(markdown).toContain("![Test Image](https://substackcdn.com/image/fetch/image.jpg)");
      // For now, turndown still processes the link wrapper due to rule ordering
      // The important thing is that the image itself is preserved correctly
    });

    it("should preserve regular images", () => {
      const html = `<img src="https://example.com/image.jpg" alt="Regular Image">`;
      
      const markdown = convertToMarkdown(html);
      expect(markdown.trim()).toBe("![Regular Image](https://example.com/image.jpg)");
    });

    it("should preserve regular links", () => {
      const html = `<a href="https://example.com">Regular Link</a>`;
      
      const markdown = convertToMarkdown(html);
      expect(markdown.trim()).toBe("[Regular Link](https://example.com)");
    });
  });

  describe("content preservation", () => {
    it("should preserve most of the content length", async () => {
      const longContent = "This is a test paragraph. ".repeat(100);
      const html = `<article><p>${longContent}</p></article>`;
      const dom = new JSDOM(html);
      
      const extractedContent = extractContent(dom);
      const markdown = convertToMarkdown(extractedContent);
      
      // Calculate word counts
      const originalWords = longContent.split(/\s+/).length;
      const markdownWords = markdown.split(/\s+/).length;
      
      // Should preserve at least 90% of the content
      expect(markdownWords).toBeGreaterThan(originalWords * 0.9);
    });

    it("should handle very long articles without truncating", () => {
      // Create a long article with 1000 paragraphs
      const paragraphs = Array.from({ length: 1000 }, (_, i) => 
        `<p>This is paragraph ${i + 1} with some content to make it longer.</p>`
      ).join("\n");
      
      const html = `<article>${paragraphs}</article>`;
      const dom = new JSDOM(html);
      
      const extractedContent = extractContent(dom);
      const markdown = convertToMarkdown(extractedContent);
      
      // Should contain content from the beginning and end
      expect(markdown).toContain("paragraph 1");
      expect(markdown).toContain("paragraph 1000");
      
      // Count paragraphs
      const paragraphCount = (markdown.match(/This is paragraph \d+/g) || []).length;
      expect(paragraphCount).toBe(1000);
    });
  });

  describe("processArticle with Diffbot and Firecrawl", () => {
    it("should process article with Diffbot API first", async () => {
      // Mock Diffbot API response
      mockedAxios.get.mockResolvedValueOnce({
        data: {
          objects: [{
            type: "article",
            title: "Test Article from Diffbot",
            text: "This is the article content from Diffbot. It needs to be much longer to avoid the fallback mechanism. The article import module checks if content is less than 100 characters and falls back to manual extraction if it is. So we need to make sure this content is sufficiently long.",
            html: "<p>This is the article content from Diffbot. It needs to be much longer to avoid the fallback mechanism.</p>",
            author: "Jane Smith",
            date: "2025-01-15T00:00:00Z",
            pageUrl: "https://example.com/article"
          }],
          request: {
            pageUrl: "https://example.com/article",
            api: "article",
            version: 3
          }
        }
      });
      
      const result = await processArticle("https://example.com/article");
      
      expect(result.title).toBe("Test Article from Diffbot");
      expect(result.author).toBe("Jane Smith");
      expect(result.date).toBe("2025-01-15");
      expect(result.content).toContain("This is the article content from Diffbot");
      expect(result.url).toBe("https://example.com/article");
      
      // Verify Diffbot was called
      expect(mockedAxios.get).toHaveBeenCalledWith(
        "https://api.diffbot.com/v3/article",
        expect.objectContaining({
          params: {
            token: "test-diffbot-key",
            url: "https://example.com/article",
            discussion: false
          }
        })
      );
    });

    it("should fallback to Firecrawl when Diffbot fails", async () => {
      // Mock Diffbot to fail
      mockedAxios.get.mockRejectedValueOnce(new Error("Diffbot API Error"));
      
      // Mock Firecrawl API response
      mockedAxios.post.mockResolvedValueOnce({
        data: {
          success: true,
          data: {
            markdown: "This is the article content from Firecrawl. It needs to be much longer to avoid the fallback mechanism. The article import module checks if content is less than 100 characters and falls back to manual extraction if it is. So we need to make sure this content is sufficiently long.",
            metadata: {
              title: "Test Article from Firecrawl",
              author: "John Doe",
              publishedDate: "2025-01-15T00:00:00Z"
            }
          }
        }
      });
      
      const result = await processArticle("https://example.com/article");
      
      expect(result.title).toBe("Test Article from Firecrawl");
      expect(result.author).toBe("John Doe");
      expect(result.content).toContain("This is the article content from Firecrawl");
    });

    it("should process article with Firecrawl API when Diffbot is not available", async () => {
      // Temporarily disable Diffbot
      delete process.env.DIFFBOT_KEY;
      // Mock Firecrawl API response with longer content to avoid fallback
      mockedAxios.post.mockResolvedValueOnce({
        data: {
          success: true,
          data: {
            markdown: "This is the article content in markdown. It needs to be much longer to avoid the fallback mechanism. The article import module checks if content is less than 100 characters and falls back to manual extraction if it is. So we need to make sure this content is sufficiently long.",
            html: "<p>This is the article content. It needs to be much longer to avoid the fallback mechanism.</p>",
            metadata: {
              title: "Test Article",
              author: "John Doe",
              publishedDate: "2025-01-15T00:00:00Z"
            }
          }
        }
      });
      
      const result = await processArticle("https://example.com/article");
      
      expect(result.title).toBe("Test Article");
      expect(result.author).toBe("John Doe");
      expect(result.date).toBe("2025-01-15");
      expect(result.content).toContain("This is the article content in markdown");
      expect(result.url).toBe("https://example.com/article");
      
      // Restore Diffbot key
      process.env.DIFFBOT_KEY = 'test-diffbot-key';
    });

    it("should fallback when both Diffbot and Firecrawl fail", async () => {
      // Mock Diffbot to fail
      mockedAxios.get.mockRejectedValueOnce(new Error("Diffbot API Error"));
      
      // Mock Firecrawl to fail
      mockedAxios.post.mockRejectedValueOnce(new Error("Firecrawl API Error"));
      
      // Then mock fallback HTML fetch
      mockedAxios.get.mockResolvedValueOnce({
        data: `
          <html>
            <head>
              <title>Fallback Article</title>
            </head>
            <body>
              <article>
                <h1>Fallback Article</h1>
                <p>Fallback content</p>
              </article>
            </body>
          </html>
        `
      });
      
      const result = await processArticle("https://example.com/article");
      
      expect(result.title).toBe("Fallback Article");
      expect(result.content).toContain("Fallback content");
    });

    it("should fallback when Firecrawl returns short content", async () => {
      // Mock Diffbot to fail first
      mockedAxios.get.mockRejectedValueOnce(new Error("Diffbot API Error"));
      
      // Mock Firecrawl to return very short content
      mockedAxios.post.mockResolvedValueOnce({
        data: {
          success: true,
          data: {
            markdown: "Too short",
            metadata: {
              title: "Short",
              author: "Author",
              publishedDate: "2025-01-15T00:00:00Z"
            }
          }
        }
      });
      
      // Then mock fallback HTML fetch
      mockedAxios.get.mockResolvedValueOnce({
        data: `
          <html>
            <head>
              <title>Longer Article</title>
            </head>
            <body>
              <article>
                <h1>Longer Article</h1>
                <p>This is much longer content that should be used instead</p>
              </article>
            </body>
          </html>
        `
      });
      
      const result = await processArticle("https://example.com/article");
      
      expect(result.content).toContain("much longer content");
    });
  });
});