#!/usr/bin/env tsx

/**
 * Build script to generate tool README files from source code
 *
 * Generates TWO outputs:
 * 1. Markdown files for human reading (in src/tools/TOOL_NAME/README.md)
 * 2. TypeScript module for runtime access (in src/tools/generated-readmes.ts)
 *
 * Approach:
 * - Tools with readme-generator.ts: Import generator, write markdown, include in TypeScript
 * - Tools with static README.md: Read file, include in TypeScript (no generation)
 */

import fs from 'fs';
import path from 'path';
import { createHash } from 'crypto';

// Import all tools from centralized registry to get tool IDs
import { allTools } from '../src/tools/all-tools';

/**
 * Auto-discover and load readme generators for tools
 * Looks for readme-generator.ts files in each tool directory
 */
async function loadGenerators(): Promise<{
  generators: Record<string, () => string>;
  failures: string[]
}> {
  const generators: Record<string, () => string> = {};
  const failures: string[] = [];
  const toolsDir = path.join(__dirname, '..', 'src', 'tools');

  for (const [id] of Object.entries(allTools)) {
    const generatorPath = path.join(toolsDir, id, 'readme-generator.ts');

    if (fs.existsSync(generatorPath)) {
      try {
        const module = await import(`../src/tools/${id}/readme-generator`);
        if (module.generateReadme && typeof module.generateReadme === 'function') {
          generators[id] = module.generateReadme;
        } else {
          const error = 'Generator module does not export generateReadme function';
          console.error(`‚ùå Failed to load generator for ${id}: ${error}`);
          failures.push(`${id}: ${error}`);
        }
      } catch (error) {
        console.error(`‚ùå Failed to load generator for ${id}:`, error);
        failures.push(`${id}: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  }

  return { generators, failures };
}

// Main execution wrapped in async function
async function main() {
  // Auto-discover generators
  const { generators: TOOLS_WITH_GENERATORS, failures: loadFailures } = await loadGenerators();
  const generationFailures: string[] = [];

  // Generate or read README files
  const readmes: Record<string, string> = {};

  for (const [id, tool] of Object.entries(allTools)) {
    const staticReadmePath = path.join(__dirname, '..', 'src', 'tools', id, 'README.md');

    // Check if tool has a programmatic generator
    if (id in TOOLS_WITH_GENERATORS) {
      try {
        const generator = TOOLS_WITH_GENERATORS[id];
        const content = generator();
        readmes[id] = content;

        // Write markdown file for human reading
        fs.writeFileSync(staticReadmePath, content, 'utf-8');
        console.log(`‚úÖ Generated README for ${id} (programmatic)`);
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        console.error(`‚ùå Failed to generate README for ${id}:`, error);
        generationFailures.push(`${id}: ${errorMsg}`);
        readmes[id] = `# ${tool.config.name}\n\n*README generation failed*`;
      }
    }
    // Fall back to static README.md
    else if (fs.existsSync(staticReadmePath)) {
      try {
        readmes[id] = fs.readFileSync(staticReadmePath, 'utf-8');
        console.log(`‚úÖ Loaded README for ${id} (static)`);
      } catch (error) {
        console.warn(`‚ö†Ô∏è  Failed to read README for ${id}:`, error);
        readmes[id] = `# ${tool.config.name}\n\n*README content not available*`;
      }
    } else {
      console.warn(`‚ö†Ô∏è  No README found for ${id}`);
      readmes[id] = `# ${tool.config.name}\n\n*README content not available*`;
    }
  }

  // Create a hash of the README content for validation
  const readmeContent = JSON.stringify(readmes, null, 2);
  const readmeHash = createHash('sha256').update(readmeContent).digest('hex');

  // Generate TypeScript module for runtime access
  const tsOutput = `/**
 * Auto-generated tool README content
 * Generated by scripts/generate-tool-readmes.ts
 * DO NOT EDIT MANUALLY
 *
 * README Hash: ${readmeHash}
 */

export const toolReadmes = ${JSON.stringify(readmes, null, 2)} as const;

export type ToolId = keyof typeof toolReadmes;

export function getToolReadme(toolId: string): string {
  const typedToolId = toolId as ToolId;
  return toolReadmes[typedToolId] || \`# \${toolId}\\n\\n*README content not available*\`;
}
`;

  // Write TypeScript module
  const tsOutputPath = path.join(__dirname, '..', 'src', 'tools', 'generated-readmes.ts');
  fs.writeFileSync(tsOutputPath, tsOutput, 'utf-8');

  console.log(`‚úÖ Generated TypeScript module at ${tsOutputPath}`);
  console.log(`üìã Generated ${Object.keys(readmes).length} README entries`);
  console.log(`üîç README hash: ${readmeHash}`);

  // Report all failures and exit with error if any occurred
  const allFailures = [...loadFailures, ...generationFailures];
  if (allFailures.length > 0) {
    console.error('\n‚ùå README generation completed with failures:');
    allFailures.forEach(failure => console.error(`  - ${failure}`));
    process.exit(1);
  }
}

// Run the script
main().catch(error => {
  console.error('Fatal error:', error);
  process.exit(1);
});