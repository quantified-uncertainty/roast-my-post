/**
 * Shared utilities for README generation scripts
 * Reduces duplication between generate-tool-readmes.ts and generate-plugin-readmes.ts
 */

import fs from 'fs';
import path from 'path';
import { createHash } from 'crypto';

export interface GeneratorConfig {
  generator: () => string;
  markdownOutputPath?: string;
}

export interface GeneratorResult {
  readmes: Record<string, string>;
  loadFailures: string[];
  generationFailures: string[];
}

/**
 * Auto-discover and load readme generators from a directory
 * @param baseDir Directory containing items with readme-generator.ts files
 * @param itemIds Array of item IDs to check for generators
 * @param pathTemplate Function to generate path to readme-generator.ts for an item
 * @returns Object with generators, failures
 */
export async function loadGenerators(
  baseDir: string,
  itemIds: string[],
  pathTemplate: (id: string) => string
): Promise<{
  generators: Record<string, () => string>;
  failures: string[];
}> {
  const generators: Record<string, () => string> = {};
  const failures: string[] = [];

  for (const id of itemIds) {
    const generatorPath = path.join(baseDir, pathTemplate(id));

    if (fs.existsSync(generatorPath)) {
      try {
        const module = await import(generatorPath);
        if (module.generateReadme && typeof module.generateReadme === 'function') {
          generators[id] = module.generateReadme;
        } else {
          const error = 'Generator module does not export generateReadme function';
          console.error(`‚ùå Failed to load generator for ${id}: ${error}`);
          failures.push(`${id}: ${error}`);
        }
      } catch (error) {
        console.error(`‚ùå Failed to load generator for ${id}:`, error);
        failures.push(`${id}: ${error instanceof Error ? error.message : String(error)}`);
      }
    }
  }

  return { generators, failures };
}

/**
 * Generate READMEs from a map of generator configs
 * @param configs Map of ID to generator config
 * @param scriptDir Directory of the calling script (for resolving relative paths)
 * @returns Object with readme content and failures
 */
export function generateReadmesFromConfigs(
  configs: Record<string, GeneratorConfig>,
  scriptDir: string
): { content: Record<string, string>; failures: string[] } {
  const content: Record<string, string> = {};
  const failures: string[] = [];

  for (const [id, config] of Object.entries(configs)) {
    try {
      const readmeContent = config.generator();
      content[id] = readmeContent;

      // Write markdown file if output path specified
      if (config.markdownOutputPath) {
        const markdownPath = path.join(scriptDir, config.markdownOutputPath);
        const dir = path.dirname(markdownPath);
        if (!fs.existsSync(dir)) {
          fs.mkdirSync(dir, { recursive: true });
        }
        fs.writeFileSync(markdownPath, readmeContent, 'utf-8');
        console.log(`‚úÖ Generated markdown README for ${id} at ${markdownPath}`);
      } else {
        console.log(`‚úÖ Generated README for ${id} (programmatic)`);
      }
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      console.error(`‚ùå Failed to generate README for ${id}:`, error);
      failures.push(`${id}: ${errorMsg}`);
    }
  }

  return { content, failures };
}

/**
 * Generate TypeScript module with README content
 * @param readmes Map of ID to README content
 * @param config Output configuration
 */
export function generateTypeScriptModule(
  readmes: Record<string, string>,
  config: {
    scriptName: string;
    exportName: string;
    typeName: string;
    getterName: string;
    outputPath: string;
  }
): void {
  const readmeHash = createHash('sha256')
    .update(JSON.stringify(readmes))
    .digest('hex');

  const tsOutput = `/**
 * Auto-generated README content
 * Generated by ${config.scriptName}
 * DO NOT EDIT MANUALLY
 *
 * README Hash: ${readmeHash}
 */

export const ${config.exportName} = ${JSON.stringify(readmes, null, 2)} as const;

export type ${config.typeName} = keyof typeof ${config.exportName};

export function ${config.getterName}(id: string): string {
  const typedId = id as ${config.typeName};
  return ${config.exportName}[typedId] || \`# \${id}\\n\\n*README content not available*\`;
}
`;

  fs.writeFileSync(config.outputPath, tsOutput, 'utf-8');
  console.log(`‚úÖ Generated TypeScript module at ${config.outputPath}`);
  console.log(`üìã Generated ${Object.keys(readmes).length} README entries`);
  console.log(`üîç README hash: ${readmeHash}`);
}

/**
 * Report failures and exit if any occurred
 */
export function reportFailuresAndExit(failures: string[]): void {
  if (failures.length > 0) {
    console.error('\n‚ùå README generation completed with failures:');
    failures.forEach(failure => console.error(`  - ${failure}`));
    process.exit(1);
  }
}
